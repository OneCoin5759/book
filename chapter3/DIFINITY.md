# Dfinity系列（一）——分层架构、阈值接力

## 摘要

&emsp;&emsp;本期分享会由题华龙同学进行分享，由龚劼同学进行整理。本期分享会主要介绍了Dfinity系统中的分层架构和阈值接力这两个核心概念，其他比较重要的概念将在以后再次介绍。

## Dfinity基本信息

### 背景介绍

&emsp;&emsp;Dfinity项目的创建想法始于2014年，最初目标是做大规模计算的支付平台，只支持代币功能。而随着以太坊项目的发起，Dfinity受到启发，想要做一个更通用的平台。

&emsp;&emsp;2016年初，Dfinity正式立项，在此期间与世界五百强的企业进行了长时间的咨询与交流。Dfinity作为一个公链，其算法的性能是完全可以做联盟链和私有链。

### 项目愿景

&emsp;&emsp;Dfinity的目标是做一个无限计算、无限扩容的世界计算机，那么他至少要解决三方面的问题：1.交易速度；2.吞吐量；3.自适应能力。

1. 交易速度。主要是靠阈值算法接力来实现，测试版本可以达到确认时间为7.5秒；
2. 吞吐量。主要靠分层架构解决。Dfinity内部分为三层架构，与比特币、以太坊不同，矿工做的不一定是同样的工作。 
3. 自适应能力。即自动调整以修改出块时间、阈值组的大小、恶意智能合约的回滚，并且不会产生新的分叉。

### 优势介绍

- **兼容EVM**

&emsp;&emsp;Dfinity完全兼容以太坊虚拟机，无需再学习一门新的智能合约语言。

- **更高的性能**

	1. 三层架构横向扩展；
	2. 阈值接力以快速出块快速确认；
	3. 概率插槽协议增加区块事务数。

- **支持拜占庭容错**


- **可解决公共纠纷的治理机制**

## 分层架构

![](https://i.imgur.com/jpmjN3y.png)

### 分层架构介绍

&emsp;&emsp;分层架构如上图所示，主要分为存储、验证·、共识三层。

- **存储层**

	&emsp;&emsp;分成多个分片，而这个分片与以太坊未来的分片计划类似，每个分片处理这一部分的交易数据，该交易数据生成一个验证数传到验证层。

- **验证层**
 
	&emsp;&emsp;验证层其实是一个异步结构，可以理解为一个Merkle Tree。这个验证层的验证数据是由每个随机灯塔选出来阈值组来进行验证。（阈值组作为Dfinity核心概念会在后面会介绍到）

- **共识层**
 
	&emsp;&emsp;共识层是两个作用，一个是要记录验证层的根状态的数据（即Merkle Tree的根）。它并不记录具体的交易数据信息，这些都是存储层存储。在另一个是根据随机灯塔选出验证数所属的组。

### 新的问题

1. 存储层是分片的，分片状态数据如果涉及到跨分片交易，其实是有困难的。
2. 每个分片只有一部分的数据，没有一个节点拥有完整的数据。
### 本章小结

&emsp;&emsp;这样的设计理念其实与隔离验证和闪电网络是相似的。隔离见证实际上是把交易数据和验证数据隔离开来，验证归验证、数据归数据。只不过Dfinity做的更加彻底，变成了不同的分层。

&emsp;&emsp;而关于分片的理念，在以太坊未来的路线图里，也包括状态分片这种概念。但以太坊是由传统的POW转POS，需要一定的时间周期，因此这样的分片概念还需要一定时间才能部署到主网上。同时以太坊有着从全局复制到分片这样一个相当大的差异，所以很可能需要相当长的时间，或者会产生新的分叉。所以Dfinity的推出速度和前瞻性，可能将会成为一个相当大的优势。

## 阈值接力

### 签名机制

![](https://i.imgur.com/IbRQlJ1.png)

- **传统签名机制**

	&emsp;&emsp;在传统的签名机制中，如果有一个唯一的签名者，如果签名的方案具有唯一性和确定性，那么只会产生一个唯一的正确签名。

- **Dfinity签名机制** 

	&emsp;&emsp;Dfinty签名机制的开创性在于，采用了组签名的算法（BLS）。其特点是，一个组有多个成员，每个成员都是一个签名者，这些签名者共同签名产生一个完整的签名。但是这个签名不一定需要成员组所有的成员参与才能产生，只需要参与签名的成员数达到阈值。且当成员数达到或超过阈值后，签名的结果将不会再发生改变。

	&emsp;&emsp;举例：假如一个组初始成员是400，那么约定签名成员达到201，该签名才生效。因此当签名成员数少于201时，根据人数的不同，签名结果并不唯一，且不会被系统所采纳。当签名成员数等于或大于201时，将会得到同样的签名结果。

- **组签名机制带来的好处**

	&emsp;&emsp;没有一个个体成员能预测到签名的结果（除非有超过阈值个数的成员窜通）。

	&emsp;&emsp;因为只要达到条件就能计算签名，所以当成员组中有少数个体不签名或恶意地拒绝签名，是无法阻止整个签名的生成的。


### BLS算法过程

- **初始化(生成个人公钥和组公钥)**

	1. 每个成员i 生成自己的随机数组rani（对其他人保密，包括同组成员）。
	2. 使用BLS 签名算法给出的函数f 计算出sendij = f(rani; j)，通过私密通道发送sendij 给成员j。对所有j(= 1; 2; :::;N)，成员i 要对成员j 发送sendij（包括自己）。
	3. 每个成员j 收集数据send1j ; send2j ; :::; sendNj，用BLS 签名算法给出的验证函数v 验证sendij(i = 1; 2; :::;N) 的合法性。
	4. 全部验证合法后，用它们计算出自己的秘钥sj，sj 对应的公钥pubj，组公钥P。	
	5. 将pubj 以及P 广播。

- **签名**

	&emsp;&emsp;每个成员i用秘钥si 对消息M 签名得到sigi 并广播sigi。

	&emsp;&emsp;每个成员j收集其他成员广播的sigi，并用pubi 验证，通过验证则作为有效签名接受。当收集到k 个有效签名（包括自己的签名sigj），则计算出最终签名SIG 并广播SIG。

### 具体过程

- **阈值接力基本思想**

	1. 将全网分为h个组；
	2. 第一组生成一个随机数签名1，使用签名1选取第二组；
	3. 第二组对随机数签名1签名得到签名2，使用签名2选取第三组；
	4. 第三组再对签名2 签名得到签名3，循环往复。
	
- **在Dfinity上运行的过程**

	1. 新加入网络的客户端通过VRF算法被随机分配到不同的组；
	2. 初始化阈值组的参数(组大小，阈值等)[在1000个区块之内完成阈值初始化参数]；
	3. 初始化完毕，成功创建的组的公钥被登记到网络中[不同的组是并行创建的]；
	4. 新加入的阈值组以及客户端需要等待2个EPOCH周期才能够激活。

### 阈值组模型

![](https://i.imgur.com/sjKWLR6.png)

&emsp;&emsp;这是官网挂出来的一个阈值组模型。不同的点代表不同的阈值组，每一个高度只有一个阈值组进行工作，然后计算出下一个应该工作的阈值组。每个阈值组随时监测区块链网络，若前一个区块链的高度是本阈值组，则会停止监测，进行出块的工作。（出块涉及到概率插槽这样具体的策略，将在以后进行分享）